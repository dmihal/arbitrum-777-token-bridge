//SPDX-License-Identifier: MIT
pragma solidity ^0.7.0;

import "@openzeppelin/contracts/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@uniswap/lib/contracts/libraries/SafeERC20Namer.sol";
import "@uniswap/lib/contracts/libraries/TransferHelper.sol";
import "../L2/BridgedTokenFactory.sol";
import "../L2/BridgedERC777Token.sol";
import "./DecimalConverter.sol";
import "./ILiquidityProvider.sol";
import "./TicketFactory.sol";

interface IInbox {
  function deployL2ContractPair(
    uint256 maxGas,
    uint256 gasPriceBid,
    uint256 payment,
    bytes calldata contractData
  ) external;

  function sendContractTransaction(
    uint256 maxGas,
    uint256 gasPriceBid,
    address destAddr,
    uint256 amount,
    bytes calldata data
  ) external;

  function depositEth(address destAddr) external payable;
}

contract Vault {
  IInbox public immutable inbox;
  TicketFactory public immutable ticketFactory;

  bytes32 public constant TOKEN_BYTECODE_HASH = keccak256(type(BridgedERC777Token).creationCode);

  event Withdrawal(address indexed owner, address indexed recipient, bytes32 indexed claim, uint256 erc20Amount);
  event TicketIssued(address indexed owner, address indexed recipient, bytes32 indexed claim, uint256 payment);

  constructor(IInbox _inbox, TicketFactory _ticketFactory) public {
    inbox = _inbox;
    ticketFactory = _ticketFactory;
  }

  /**
    * Deploy token factory as buddy on L2
    */
  function connectToChain(uint256 maxGas, uint256 gasPriceBid) external payable {
    // Pay for gas
    if (msg.value > 0) {
      inbox.depositEth{ value: msg.value }(address(this));
    }
    // TODO: don't include this bytecode in the state
    inbox.deployL2ContractPair(
      maxGas, // max gas
      gasPriceBid, // gas price
      0, // payment
      type(BridgedTokenFactory).creationCode
    );
  }

  /**
    * Transfer token from caller to vault, mint 777 token to `destination` on L2
    *
    * TODO: deposit with permit()
    */
  function deposit(
    address token,
    address destination,
    uint256 amount,
    uint256 maxGas,
    uint256 gasPriceBid
  ) external payable /*onlyIfConnected*/ {
    TransferHelper.safeTransferFrom(msg.sender, address(this), amount);

    uint256 erc777Amount = DecimalConverter.from20to777(ERC20(token).decimals(), amount);

    // This transfers along any ETH sent for to pay for gas in L2
    sendPairedContractTransaction(
      maxGas,
      gasPriceBid,
      abi.encodeWithSelector(
        BridgedTokenFactory.deposit.selector,
        token,
        destination,
        erc777Amount
      )
    );
  }

  /**
    * Liquidity provider can claim a ticket, claiming a withdrawl that was initated by another
    * user, as long as they have an appropriate signature from that user.
    *
    * @param token Address of the L1 ERC20 token
    * @param owner Original recipient, typically the user who initiated the withdrawal
    * @param claim The unique ID of the withdrawal, generated by the L2 bridge
    * @param recipient The recipient of the ticket, typically the transaction sender
    * @param payment The amount that the LP will transfer to the owner (typically the withdrawal, minus a fee)
    * @param expiration Expiration date of the signature
    * @param signature All details, signed by the `owner`
    */
  function buyTicket(
    address token,
    address owner,
    bytes32 claim,
    address recipient,
    uint256 payment,
    uint256 expiration,

    bytes calldata signature
  ) external {
    require(expiration < block.timestamp, "EXPIRED");
    bytes32 saleHash = keccak256(abi.encodePacked(token, claim, recipient, payment, expiration));
    address signer = ECDSA.recover(saleHash, signature);
    require(signer == owner, "BAD_SIG");

    if (payment > 0) {
      TransferHelper.safeTransferFrom(token, msg.sender, owner, payment);
    }

    ticketFactory.mint(token, owner, claim, recipient);
    
    emit TicketIssued(owner, recipient, claim, payment);
  }

  /**
    * The reverse of buyTicket, allowing the user to pay the L1 transaction fee
    * User can give a ticket to a liquidity provider. The LP contract (which implements the
    * ILiquidityProvider interface) will be called with details of the ticket, and will be
    * responsible for validating a signature and transfering tokens to the user.
    *
    * @param token Address of the L1 ERC20 token
    * @param claim The unique ID of the withdrawal, generated by the L2 bridge
    * @param recipient The recipient of the ticket, which must implement ILiquidityProvider
    * @param payment Payment amount, passed to the recipient
    * @param expiration Expiration date, passed to the recipient
    * @param signature Signature details, which are not validated, but passed to the recipient
    */
  function giveTicket(
    address token,
    bytes32 claim,
    address recipient,
    uint256 payment,
    uint256 expiration,

    bytes calldata signature
  ) external {
    uint256 id = ticketFactory.mint(token, msg.sender, claim, recipient);

    ILiquidityProvider(recipient).receiveTicket(token, msg.sender, claim, payment, expiration, signature, id);
    
    emit TicketIssued(msg.sender, recipient, claim, payment);
  }

  /**
    * This function is called by the bridge, withdrawing any token from the bridge.
    * If a valid ticket exists, tokens are transferred to the ticket holder, otherwise
    * to the original recipient.
    *
    * @param claim The unique ID of the withdrawal, generated by the L2 bridge
    * @param token Address of the L1 ERC20 token
    * @param owner The original recipient, typically the user that initated the withdrawal
    * @param amount Tokens to withdraw, with 18 decimals
    */
  function withdrawFromL2(
    bytes32 claim,
    address token,
    address owner,
    uint256 amount
  ) external override /*onlyIfConnected onlyL2*/ {
    // This method is only callable by this contract's buddy contract on L2
    // require(l2Sender() == address(this), "L2_SENDER");

    address recipient;
    if (ticketFactory.exists(address(this), token, owner, claim)) {
      recipient = ticketFactory.burn(token, owner, claim);
    } else {
      recipient = owner;
    }

    uint256 erc20Amount = DecimalConverter.from777to20(IERC20(token).decimals(), amount);

    TransferHelper.safeTransfer(token, recipient, erc20Amount);
    emit Withdrawal(owner, recipient, claim, erc20Amount);
  }

  /**
    * Update the name, symbol & decimals of the L2 token.
    */
  function updateTokenInfo(
    address token,
    uint256 maxGas,
    uint256 gasPriceBid
  ) external payable /*onlyIfConnected*/ {
    string memory name;
    string memory symbol;
    uint256 granularity = 1;

    try SafeERC20Namer.tokenName(token) returns (string memory _name) {
      name = _name;
    } catch {}
    try SafeERC20Namer.tokenSymbol(token) returns (string memory _symbol) {
      symbol = _symbol;
    } catch {}
    try ERC20(token).decimals() returns (uint8 _decimals) {
      granularity = 10 ** (18 - _decimals);
    } catch {}

    sendPairedContractTransaction(
      maxGas,
      gasPriceBid,
      abi.encodeWithSelector(
        BridgedTokenFactory.updateTokenInfo.selector,
        token,
        name,
        symbol,
        granularity
      )
    );
  }

  function sendPairedContractTransaction(
    uint256 maxGas,
    uint256 gasPriceBid,
    bytes memory data
  ) private {
    inbox.depositEth{ value: msg.value }(address(this));
    inbox.sendContractTransaction(maxGas, gasPriceBid, address(this), 0, data);
  }
}
